{"version":3,"file":"wheeling.min.js","sources":["../../../src/internals/promise.js","../../../src/internals/core.js","../../../src/hooks.js","../../../src/options.js","../../../src/wheeling.js"],"sourcesContent":["/**\r\n * @module wheeling\r\n * @copyright Lcf.vs 2022\r\n * @licence MIT\r\n * @link https://github.com/Lcfvs/wheeling\r\n * @preserve\r\n */\r\n\r\nconst memo = []\r\n\r\nconst resolvers = new WeakMap()\r\n\r\nconst pick = (resolve, reject) =>\r\n  memo.unshift([resolve, reject])\r\n\r\nconst race = async (...promises) =>\r\n  Promise.race(promises)\r\n\r\nconst resolvable = () => {\r\n  const promise = new Promise(pick)\r\n\r\n  resolvers.set(promise, memo.shift())\r\n\r\n  return promise\r\n}\r\n\r\nconst resolver = (promise, key) => {\r\n  const value = resolvers.get(promise)?.[key]\r\n\r\n  resolvers.delete(promise)\r\n\r\n  return value\r\n}\r\n\r\nconst resolve = (promise, value) =>\r\n  resolver(promise, 0)?.(value)\r\n\r\nconst reject = (promise, error) =>\r\n  resolver(promise, 1)?.(error)\r\n\r\nconst pending = async promise => {\r\n  const pending = {}\r\n\r\n  return (await race(promise, pending)) === pending\r\n}\r\n\r\nexport {\r\n  pending,\r\n  race,\r\n  reject,\r\n  resolvable,\r\n  resolve,\r\n  resolver\r\n}\r\n","/**\r\n * @module wheeling\r\n * @copyright Lcf.vs 2022\r\n * @licence MIT\r\n * @link https://github.com/Lcfvs/wheeling\r\n * @preserve\r\n */\r\n\r\nimport { pending, race, reject, resolvable, resolve, resolver } from './promise.js'\r\n\r\nconst cast = async function* (iterable) {\r\n  yield* iterable\r\n}\r\n\r\nconst handleEvent = async function (event) {\r\n  const { forget, hooks, input, options } = this\r\n  const { once } = options\r\n  const target = event.currentTarget ?? event.target\r\n  const promise = resolvable()\r\n  let returned\r\n\r\n  for (const hook of hooks) {\r\n    returned = hook(event, promise) ?? returned\r\n  }\r\n\r\n  if (once) {\r\n    forget()\r\n  }\r\n\r\n  if (returned !== promise) {\r\n    await input.next({ event, target })\r\n\r\n    return\r\n  }\r\n\r\n  const [resolve, reject] = resolver(promise)\r\n\r\n  await input.next({ event, resolve, reject, target })\r\n}\r\n\r\nconst iterate = async function* (app, promises, keys, key, reader) {\r\n  const entries = promises.get(key)\r\n\r\n  try {\r\n    while (await pending(app)) {\r\n      if (!entries.length) {\r\n        const promise = race(app, reader.next())\r\n\r\n        for (const key of keys) {\r\n          promises.get(key).push(promise)\r\n        }\r\n      }\r\n\r\n      const { done, value } = await race(app, entries.shift())\r\n\r\n      if (done) {\r\n        break\r\n      }\r\n\r\n      yield value\r\n    }\r\n  } catch {} finally {\r\n    keys.delete(key)\r\n    promises.delete(key)\r\n  }\r\n}\r\n\r\nconst readable = async function* (app, promises) {\r\n  try {\r\n    while (promises.length) {\r\n      const [input, next] = promises\r\n\r\n      resolve(next)\r\n      yield race(app, input)\r\n    }\r\n  } catch {} finally {\r\n    if (promises.length) {\r\n      reject(promises.at(-1))\r\n    }\r\n  }\r\n}\r\n\r\nconst writable = async function* (app, promises) {\r\n  try {\r\n    while (promises.length) {\r\n      const [input, current] = promises\r\n\r\n      await race(app, current)\r\n      promises.splice(0, 2, resolvable(), resolvable())\r\n      resolve(input, yield)\r\n    }\r\n  } catch {}\r\n}\r\n\r\nexport {\r\n  cast,\r\n  handleEvent,\r\n  iterate,\r\n  readable,\r\n  writable\r\n}\r\n","/**\r\n * @module wheeling/hooks.js\r\n * @copyright Lcf.vs 2022\r\n * @licence MIT\r\n * @link https://github.com/Lcfvs/wheeling\r\n */\r\n\r\nconst awaitUntil = (event, promise) => {\r\n  event.waitUntil(promise)\r\n\r\n  return promise\r\n}\r\n\r\nconst preventDefault = event =>\r\n  event.preventDefault()\r\n\r\nconst respondWith = (event, promise) => {\r\n  event.respondWith(promise)\r\n\r\n  return promise\r\n}\r\n\r\nconst stopImmediatePropagation = event =>\r\n  event.stopImmediatePropagation()\r\n\r\nconst stopPropagation = event =>\r\n  event.stopPropagation()\r\n\r\nexport {\r\n  awaitUntil,\r\n  preventDefault,\r\n  respondWith,\r\n  stopImmediatePropagation,\r\n  stopPropagation\r\n}\r\n","/**\r\n * @module wheeling/options.js\r\n * @copyright Lcf.vs 2022\r\n * @licence MIT\r\n * @link https://github.com/Lcfvs/wheeling\r\n */\r\n\r\nconst capture = true\r\n\r\nconst once = true\r\n\r\nconst passive = true\r\n\r\nexport {\r\n  capture,\r\n  once,\r\n  passive\r\n}\r\n","/**\r\n * @module wheeling/wheeling.js\r\n * @copyright Lcf.vs 2022\r\n * @licence MIT\r\n * @link https://github.com/Lcfvs/wheeling\r\n */\r\n\r\nimport { cast, handleEvent, iterate, readable, writable } from './internals/core.js'\r\nimport { reject, resolvable, resolve } from './internals/promise.js'\r\n\r\nconst apps = new WeakMap()\r\n\r\nconst add = async (app, [...iterables]) => {\r\n  const promises = []\r\n\r\n  for (const iterable of iterables) {\r\n    const promise = resolvable()\r\n\r\n    promises.push(promise)\r\n\r\n    queueMicrotask(async () => {\r\n      while (true) {\r\n        const current = iterable.next()\r\n\r\n        resolve(promise)\r\n\r\n        if ((await current).done) {\r\n          break\r\n        }\r\n      }\r\n    })\r\n  }\r\n\r\n  await Promise.all(promises)\r\n}\r\n\r\nconst fork = (app, iterable, length = 2) => {\r\n  const iterables = []\r\n  const keys = new Set(Array.from({ length }, Object))\r\n  const promises = new WeakMap()\r\n  const reader = cast(iterable)\r\n\r\n  for (const key of keys) {\r\n    promises.set(key, [])\r\n    iterables.push(iterate(app, promises, keys, key, reader))\r\n  }\r\n\r\n  return iterables\r\n}\r\n\r\nconst init = () => {\r\n  const app = resolvable()\r\n\r\n  apps.set(app, new WeakMap())\r\n\r\n  return app\r\n}\r\n\r\nconst io = app => {\r\n  const promises = [resolvable(), resolvable()]\r\n  const input = writable(app, promises)\r\n  const output = readable(app, promises)\r\n\r\n  input.next()\r\n\r\n  return [input, output]\r\n}\r\n\r\nconst listen = async function* (app, target, listener) {\r\n  const listeners = apps.get(app)\r\n\r\n  if (!listeners.has(target)) {\r\n    listeners.set(target, new WeakMap())\r\n  }\r\n\r\n  const handlers = listeners.get(target)\r\n\r\n  if (handlers.has(listener)) {\r\n    throw new Error('Duplicate event listening')\r\n  }\r\n\r\n  const { hooks: [...hooks] = [], type, ...options } = listener\r\n  const ref = new WeakRef(target)\r\n  const [input, output] = io(app)\r\n  const forget = () => {\r\n    ref.deref()?.removeEventListener(type, handler, options)\r\n    handlers.delete(listener)\r\n    input.return()\r\n  }\r\n  const registry = new FinalizationRegistry(forget)\r\n  const handler = { forget, input, handleEvent, hooks, options }\r\n\r\n  registry.register(target, null)\r\n  handlers.set(listener, handler)\r\n  target.addEventListener(type, handler, options)\r\n\r\n  try {\r\n    yield * output\r\n  } finally {\r\n    forget()\r\n  }\r\n}\r\n\r\nconst task = async function* (app, iterable, task) {\r\n  const [iterator] = fork(app, iterable, 1)\r\n\r\n  for await (const value of iterator) {\r\n    yield task(value) ?? value\r\n  }\r\n}\r\n\r\nconst revoke = app => {\r\n  reject(app)\r\n  apps.delete(app)\r\n}\r\n\r\nexport * from './hooks.js'\r\nexport * from './options.js'\r\n\r\nexport {\r\n  add,\r\n  fork,\r\n  init,\r\n  io,\r\n  listen,\r\n  revoke,\r\n  task\r\n}\r\n"],"names":["memo","resolvers","WeakMap","pick","resolve","reject","unshift","race","async","promises","Promise","resolvable","promise","set","shift","resolver","key","value","get","delete","error","pending","handleEvent","event","forget","hooks","input","options","this","once","target","currentTarget","returned","hook","next","iterate","app","keys","reader","entries","length","push","done","awaitUntil","waitUntil","preventDefault","respondWith","stopImmediatePropagation","stopPropagation","capture","passive","apps","add","iterables","iterable","queueMicrotask","current","all","fork","Set","Array","from","Object","cast","init","io","splice","writable","output","at","readable","listen","listener","listeners","has","handlers","Error","type","ref","WeakRef","deref","removeEventListener","handler","return","registry","FinalizationRegistry","register","addEventListener","task","iterator","revoke"],"mappings":"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"}