/**
 * @preserve
 * @module wheeling
 * @copyright Lcf.vs 2022
 * @licence MIT
 * @link https://github.com/Lcfvs/wheeling
 */
const t=[],e=new WeakMap,n=(e,n)=>t.unshift([e,n]),o=async(...t)=>Promise.race(t),a=()=>{const o=new Promise(n);return e.set(o,t.shift()),o},s=(t,n)=>{const o=e.get(t)?.[n];return e.delete(t),o},r=(t,e)=>s(t,0)?.(e),i=(t,e)=>s(t,1)?.(e),c=async t=>{const e={};return await o(t,e)===e},f=async function(t){const{forget:e,hooks:n,input:o,options:r}=this,{once:i}=r,c=t.currentTarget??t.target,f=a();let l;for(const a of n)l=a(t,f)??l;if(i&&e(),l!==f)return void await o.next({event:t,target:c});const[u,y]=s(f);await o.next({event:t,resolve:u,reject:y,target:c})},l=async function*(t,e,n,a,s){const r=e.get(a);try{for(;await c(t);){if(!r.length){const a=o(t,s.next());for(const t of n)e.get(t).push(a)}const{done:a,value:i}=await o(t,r.shift());if(a)break;yield i}}catch{}finally{n.delete(a),e.delete(a)}},u=(t,e)=>(t.waitUntil(e),e),y=t=>t.preventDefault(),h=(t,e)=>(t.respondWith(e),e),p=t=>t.stopImmediatePropagation(),g=t=>t.stopPropagation(),w=!0,d=!0,k=!0,v=new WeakMap,m=async(t,[...e])=>{const n=[];for(const o of e){const t=a();n.push(t),queueMicrotask((async()=>{for(;;){const e=o.next();if(r(t),(await e).done)break}}))}await Promise.all(n)},W=(t,e,n=2)=>{const o=[],a=new Set(Array.from({length:n},Object)),s=new WeakMap,r=async function*(t){yield*t}(e);for(const i of a)s.set(i,[]),o.push(l(t,s,a,i,r));return o},x=()=>{const t=a();return v.set(t,new WeakMap),t},M=t=>{const e=[a(),a()],n=async function*(t,e){try{for(;e.length;){const[n,s]=e;await o(t,s),e.splice(0,2,a(),a()),r(n,yield)}}catch{}}(t,e),s=async function*(t,e){try{for(;e.length;){const[n,a]=e;r(a),yield o(t,n)}}catch{}finally{e.length&&i(e.at(-1))}}(t,e);return n.next(),[n,s]},P=async function*(t,e,n){const o=v.get(t);o.has(e)||o.set(e,new WeakMap);const a=o.get(e);if(a.has(n))throw new Error("Duplicate event listening");const{hooks:[...s]=[],type:r,...i}=n,c=new WeakRef(e),[l,u]=M(t),y=()=>{c.deref()?.removeEventListener(r,p,i),a.delete(n),l.return()},h=new FinalizationRegistry(y),p={forget:y,input:l,handleEvent:f,hooks:s,options:i};h.register(e,null),a.set(n,p),e.addEventListener(r,p,i);try{yield*u}finally{y()}},E=async function*(t,e,n){const[o]=W(t,e,1);for await(const a of o)yield n(a)??a},b=t=>{i(t),v.delete(t)};export{m as add,u as awaitUntil,w as capture,W as fork,x as init,M as io,P as listen,d as once,k as passive,y as preventDefault,h as respondWith,b as revoke,p as stopImmediatePropagation,g as stopPropagation,E as task};
//# sourceMappingURL=wheeling.min.js.map
