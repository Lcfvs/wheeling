/**
 * @module wheeling
 * @copyright Lcf.vs 2022
 * @licence MIT
 * @see {@link https://github.com/Lcfvs/wheeling}
 * @preserve
 */
let e;const{assign:t,create:s,freeze:n}=Object,o=new WeakMap,r=s(null),i=(e=null,...t)=>n(a(e,...t)),a=(e=null,...n)=>t(s(e),...n),l=e=>e,c=(t,s)=>e={reject:s,resolve:t},f=()=>[new Promise(c),e],u=function(e){const{hooks:[...t]=[],resolvers:s}=this,[,{resolve:n}]=s.at(-1),[o,r]=f();let i;for(const a of t)i=a(e,o)??i;n(a(null,{event:e},i&&r)),s.push(f())},p=i(null,{async*listen(e,t,s=l){const{capture:n,once:a,passive:c,type:p}=t,h={capture:n,once:a,passive:c},v=[f()],d=i(t,{handleEvent:u,resolvers:v}),y=o.get(this),{listeners:k}=y;k.has(t)||k.set(t,new WeakSet);const w=k.get(t);if(w.has(e))throw new Error("Duplicate event listening");w.add(e),e.addEventListener(p,d,h);try{for(;;){const[[e]]=v,t=await Promise.race([e,y.promise]);if(t===r)break;if(yield await s(t)??t,v.shift(),v.length||v.push(f()),a)break}}finally{e.removeEventListener(p,d,h),w.delete(e)}},add([...e]){const{iterator:t}=o.get(this);for(const s of e)t.next(s);return this},async*of(e,t=l){try{for await(const s of e)yield t(s)??s}finally{e.return?.(r)}},revoke(){const e=o.get(this);if(e){const{iterator:t,resolve:s}=e;s(r),t.return(r),o.delete(this)}}}),h=e=>(queueMicrotask((async()=>{for await(const t of e)if(t===r)break})),e),v=({hooks:[...e]=[],...t})=>i(null,{hooks:n(e),...t}),d=()=>{const e=function*(){const e=[];try{for(;e.push(h(yield)););}finally{for(const t of e)t.return(r)}}(),t=i(p),s=new WeakMap,[n,{resolve:a}]=f();return o.set(t,{iterator:e,listeners:s,promise:n,resolve:a}),e.next(),t},y=(e,t)=>(e.waitUntil(t),t),k=e=>e.preventDefault(),w=(e,t)=>(e.respondWith(t),t),g=e=>e.stopImmediatePropagation(),m=e=>e.stopPropagation(),b=!0,E=!0,P=!0;export{v as listener,d as init,y as awaitUntil,k as preventDefault,w as respondWith,g as stopImmediatePropagation,m as stopPropagation,b as capture,E as once,P as passive};
//# sourceMappingURL=./wheeling.min.js.map