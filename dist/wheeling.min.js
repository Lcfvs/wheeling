/**
 * @preserve
 * @module wheeling/dist
 * @copyright Lcf.vs 2022
 * @licence MIT
 * @link https://github.com/Lcfvs/wheeling/blob/master/dist/wheeling.min.js
 */
const t=[],e=new WeakMap,n=(e,n)=>t.unshift([e,n]),o=async(...t)=>Promise.race(t),a=()=>{const o=new Promise(n);return e.set(o,t.shift()),o},r=(t,n)=>{const o=e.get(t)?.[n];return e.delete(t),o},s=(t,e)=>r(t,0)?.(e),i=(t,e)=>r(t,1)?.(e),c=async(...t)=>{const e={};return await o(...t,e)===e},f=new WeakMap,l=async(t,e)=>{h(t);const n=[];for(const o of e){const t=a();n.push(t),queueMicrotask((async()=>{for(;;){const e=o.next();if(s(t),(await e).done)break}}))}await Promise.all(n)},p=()=>{const t=a();return f.set(t,1),t},u=t=>{i(t),f.delete(t)},h=t=>{if(!f.has(t))throw new ReferenceError("Unknown app")},y=async function*(t,e,n,a,r){const s=e.get(a);try{for(;await c(t);){if(!s.length){const a=o(t,r.next());for(const t of n)e.get(t).push(a)}const{done:a,value:i}=await o(t,s.shift());if(a)break;yield i}}catch{}finally{n.delete(a),e.delete(a)}};var w=(t,e,n=2)=>{h(t);const o=[],a=new Set(Array.from({length:n},Object)),r=new WeakMap,s=async function*(t){yield*t}(e);for(const i of a)r.set(i,[]),o.push(y(t,r,a,i,s));return o},g=t=>(e,...n)=>(h(e),t(e,...n));var d=g((t=>{const e=[a(),a()],n=async function*(t,e){try{for(;e.length;){const[n,r]=e;await o(t,r),e.splice(0,2,a(),a()),s(n,yield)}}catch{}}(t,e),r=async function*(t,e){try{for(;e.length;){const[n,a]=e;s(a),yield o(t,n)}}catch{}finally{e.length&&i(e.at(-1))}}(t,e);return n.next(),[n,r]}));const v=new WeakMap,k=async function(t){const{forget:e,hooks:n,input:o,options:s}=this,{once:i}=s,c=t.currentTarget??t.target,f=a();let l;for(const a of n)l=a(t,f)??l;if(i&&e(),l!==f)return void await o.next({event:t,target:c});const[p,u]=r(f);await o.next({event:t,resolve:p,reject:u,target:c})};var m=g((async function*(t,e,n){v.has(t)||v.set(t,new WeakMap);const o=v.get(t);o.has(e)||o.set(e,new WeakMap);const a=o.get(e);if(a.has(n))throw new Error("Duplicate event listening");const{hooks:[...r]=[],type:s,...i}=n,c=new WeakRef(e),[f,l]=d(t),p=()=>{c.deref()?.removeEventListener(s,h,i),a.delete(n),f.return()},u=new FinalizationRegistry(p),h={forget:p,input:f,handleEvent:k,hooks:r,options:i};u.register(e,null),a.set(n,h),e.addEventListener(s,h,i);try{yield*l}finally{p()}})),W=g((async function*(t,e,n){const[o]=w(t,e,1);for await(const a of o)yield n(a)??a})),_=(t,e)=>(t.waitUntil(e),e),M=t=>{t.preventDefault()},P=(t,e)=>(t.respondWith(e),e),x=t=>{t.stopImmediatePropagation()},b=t=>{t.stopPropagation()},E=Object.freeze({__proto__:null,awaitUntil:_,preventDefault:M,respondWith:P,stopImmediatePropagation:x,stopPropagation:b}),j=!0,z=!0,D=!0,O=Object.freeze({__proto__:null,capture:true,once:true,passive:true});export{l as add,_ as awaitUntil,j as capture,w as fork,E as hooks,p as init,d as io,m as listen,z as once,O as options,D as passive,M as preventDefault,P as respondWith,u as revoke,x as stopImmediatePropagation,b as stopPropagation,W as task};
//# sourceMappingURL=wheeling.min.js.map
